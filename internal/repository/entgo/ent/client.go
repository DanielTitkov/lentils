// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/migrate"
	"github.com/google/uuid"

	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/interpretation"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/interpretationtranslation"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/item"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/itemtranslation"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/question"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/questiontranslation"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/response"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/scale"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/scaleitem"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/scaletranslation"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/take"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/test"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/testdisplay"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/testtranslation"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/user"
	"github.com/DanielTitkov/lentils/internal/repository/entgo/ent/usersession"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Interpretation is the client for interacting with the Interpretation builders.
	Interpretation *InterpretationClient
	// InterpretationTranslation is the client for interacting with the InterpretationTranslation builders.
	InterpretationTranslation *InterpretationTranslationClient
	// Item is the client for interacting with the Item builders.
	Item *ItemClient
	// ItemTranslation is the client for interacting with the ItemTranslation builders.
	ItemTranslation *ItemTranslationClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// QuestionTranslation is the client for interacting with the QuestionTranslation builders.
	QuestionTranslation *QuestionTranslationClient
	// Response is the client for interacting with the Response builders.
	Response *ResponseClient
	// Scale is the client for interacting with the Scale builders.
	Scale *ScaleClient
	// ScaleItem is the client for interacting with the ScaleItem builders.
	ScaleItem *ScaleItemClient
	// ScaleTranslation is the client for interacting with the ScaleTranslation builders.
	ScaleTranslation *ScaleTranslationClient
	// Take is the client for interacting with the Take builders.
	Take *TakeClient
	// Test is the client for interacting with the Test builders.
	Test *TestClient
	// TestDisplay is the client for interacting with the TestDisplay builders.
	TestDisplay *TestDisplayClient
	// TestTranslation is the client for interacting with the TestTranslation builders.
	TestTranslation *TestTranslationClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserSession is the client for interacting with the UserSession builders.
	UserSession *UserSessionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Interpretation = NewInterpretationClient(c.config)
	c.InterpretationTranslation = NewInterpretationTranslationClient(c.config)
	c.Item = NewItemClient(c.config)
	c.ItemTranslation = NewItemTranslationClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.QuestionTranslation = NewQuestionTranslationClient(c.config)
	c.Response = NewResponseClient(c.config)
	c.Scale = NewScaleClient(c.config)
	c.ScaleItem = NewScaleItemClient(c.config)
	c.ScaleTranslation = NewScaleTranslationClient(c.config)
	c.Take = NewTakeClient(c.config)
	c.Test = NewTestClient(c.config)
	c.TestDisplay = NewTestDisplayClient(c.config)
	c.TestTranslation = NewTestTranslationClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserSession = NewUserSessionClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		Interpretation:            NewInterpretationClient(cfg),
		InterpretationTranslation: NewInterpretationTranslationClient(cfg),
		Item:                      NewItemClient(cfg),
		ItemTranslation:           NewItemTranslationClient(cfg),
		Question:                  NewQuestionClient(cfg),
		QuestionTranslation:       NewQuestionTranslationClient(cfg),
		Response:                  NewResponseClient(cfg),
		Scale:                     NewScaleClient(cfg),
		ScaleItem:                 NewScaleItemClient(cfg),
		ScaleTranslation:          NewScaleTranslationClient(cfg),
		Take:                      NewTakeClient(cfg),
		Test:                      NewTestClient(cfg),
		TestDisplay:               NewTestDisplayClient(cfg),
		TestTranslation:           NewTestTranslationClient(cfg),
		User:                      NewUserClient(cfg),
		UserSession:               NewUserSessionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		Interpretation:            NewInterpretationClient(cfg),
		InterpretationTranslation: NewInterpretationTranslationClient(cfg),
		Item:                      NewItemClient(cfg),
		ItemTranslation:           NewItemTranslationClient(cfg),
		Question:                  NewQuestionClient(cfg),
		QuestionTranslation:       NewQuestionTranslationClient(cfg),
		Response:                  NewResponseClient(cfg),
		Scale:                     NewScaleClient(cfg),
		ScaleItem:                 NewScaleItemClient(cfg),
		ScaleTranslation:          NewScaleTranslationClient(cfg),
		Take:                      NewTakeClient(cfg),
		Test:                      NewTestClient(cfg),
		TestDisplay:               NewTestDisplayClient(cfg),
		TestTranslation:           NewTestTranslationClient(cfg),
		User:                      NewUserClient(cfg),
		UserSession:               NewUserSessionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Interpretation.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Interpretation.Use(hooks...)
	c.InterpretationTranslation.Use(hooks...)
	c.Item.Use(hooks...)
	c.ItemTranslation.Use(hooks...)
	c.Question.Use(hooks...)
	c.QuestionTranslation.Use(hooks...)
	c.Response.Use(hooks...)
	c.Scale.Use(hooks...)
	c.ScaleItem.Use(hooks...)
	c.ScaleTranslation.Use(hooks...)
	c.Take.Use(hooks...)
	c.Test.Use(hooks...)
	c.TestDisplay.Use(hooks...)
	c.TestTranslation.Use(hooks...)
	c.User.Use(hooks...)
	c.UserSession.Use(hooks...)
}

// InterpretationClient is a client for the Interpretation schema.
type InterpretationClient struct {
	config
}

// NewInterpretationClient returns a client for the Interpretation from the given config.
func NewInterpretationClient(c config) *InterpretationClient {
	return &InterpretationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `interpretation.Hooks(f(g(h())))`.
func (c *InterpretationClient) Use(hooks ...Hook) {
	c.hooks.Interpretation = append(c.hooks.Interpretation, hooks...)
}

// Create returns a builder for creating a Interpretation entity.
func (c *InterpretationClient) Create() *InterpretationCreate {
	mutation := newInterpretationMutation(c.config, OpCreate)
	return &InterpretationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Interpretation entities.
func (c *InterpretationClient) CreateBulk(builders ...*InterpretationCreate) *InterpretationCreateBulk {
	return &InterpretationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Interpretation.
func (c *InterpretationClient) Update() *InterpretationUpdate {
	mutation := newInterpretationMutation(c.config, OpUpdate)
	return &InterpretationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InterpretationClient) UpdateOne(i *Interpretation) *InterpretationUpdateOne {
	mutation := newInterpretationMutation(c.config, OpUpdateOne, withInterpretation(i))
	return &InterpretationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InterpretationClient) UpdateOneID(id uuid.UUID) *InterpretationUpdateOne {
	mutation := newInterpretationMutation(c.config, OpUpdateOne, withInterpretationID(id))
	return &InterpretationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Interpretation.
func (c *InterpretationClient) Delete() *InterpretationDelete {
	mutation := newInterpretationMutation(c.config, OpDelete)
	return &InterpretationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InterpretationClient) DeleteOne(i *Interpretation) *InterpretationDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *InterpretationClient) DeleteOneID(id uuid.UUID) *InterpretationDeleteOne {
	builder := c.Delete().Where(interpretation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InterpretationDeleteOne{builder}
}

// Query returns a query builder for Interpretation.
func (c *InterpretationClient) Query() *InterpretationQuery {
	return &InterpretationQuery{
		config: c.config,
	}
}

// Get returns a Interpretation entity by its id.
func (c *InterpretationClient) Get(ctx context.Context, id uuid.UUID) (*Interpretation, error) {
	return c.Query().Where(interpretation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InterpretationClient) GetX(ctx context.Context, id uuid.UUID) *Interpretation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTranslations queries the translations edge of a Interpretation.
func (c *InterpretationClient) QueryTranslations(i *Interpretation) *InterpretationTranslationQuery {
	query := &InterpretationTranslationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interpretation.Table, interpretation.FieldID, id),
			sqlgraph.To(interpretationtranslation.Table, interpretationtranslation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, interpretation.TranslationsTable, interpretation.TranslationsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScale queries the scale edge of a Interpretation.
func (c *InterpretationClient) QueryScale(i *Interpretation) *ScaleQuery {
	query := &ScaleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interpretation.Table, interpretation.FieldID, id),
			sqlgraph.To(scale.Table, scale.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, interpretation.ScaleTable, interpretation.ScaleColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InterpretationClient) Hooks() []Hook {
	return c.hooks.Interpretation
}

// InterpretationTranslationClient is a client for the InterpretationTranslation schema.
type InterpretationTranslationClient struct {
	config
}

// NewInterpretationTranslationClient returns a client for the InterpretationTranslation from the given config.
func NewInterpretationTranslationClient(c config) *InterpretationTranslationClient {
	return &InterpretationTranslationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `interpretationtranslation.Hooks(f(g(h())))`.
func (c *InterpretationTranslationClient) Use(hooks ...Hook) {
	c.hooks.InterpretationTranslation = append(c.hooks.InterpretationTranslation, hooks...)
}

// Create returns a builder for creating a InterpretationTranslation entity.
func (c *InterpretationTranslationClient) Create() *InterpretationTranslationCreate {
	mutation := newInterpretationTranslationMutation(c.config, OpCreate)
	return &InterpretationTranslationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InterpretationTranslation entities.
func (c *InterpretationTranslationClient) CreateBulk(builders ...*InterpretationTranslationCreate) *InterpretationTranslationCreateBulk {
	return &InterpretationTranslationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InterpretationTranslation.
func (c *InterpretationTranslationClient) Update() *InterpretationTranslationUpdate {
	mutation := newInterpretationTranslationMutation(c.config, OpUpdate)
	return &InterpretationTranslationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InterpretationTranslationClient) UpdateOne(it *InterpretationTranslation) *InterpretationTranslationUpdateOne {
	mutation := newInterpretationTranslationMutation(c.config, OpUpdateOne, withInterpretationTranslation(it))
	return &InterpretationTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InterpretationTranslationClient) UpdateOneID(id uuid.UUID) *InterpretationTranslationUpdateOne {
	mutation := newInterpretationTranslationMutation(c.config, OpUpdateOne, withInterpretationTranslationID(id))
	return &InterpretationTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InterpretationTranslation.
func (c *InterpretationTranslationClient) Delete() *InterpretationTranslationDelete {
	mutation := newInterpretationTranslationMutation(c.config, OpDelete)
	return &InterpretationTranslationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InterpretationTranslationClient) DeleteOne(it *InterpretationTranslation) *InterpretationTranslationDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *InterpretationTranslationClient) DeleteOneID(id uuid.UUID) *InterpretationTranslationDeleteOne {
	builder := c.Delete().Where(interpretationtranslation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InterpretationTranslationDeleteOne{builder}
}

// Query returns a query builder for InterpretationTranslation.
func (c *InterpretationTranslationClient) Query() *InterpretationTranslationQuery {
	return &InterpretationTranslationQuery{
		config: c.config,
	}
}

// Get returns a InterpretationTranslation entity by its id.
func (c *InterpretationTranslationClient) Get(ctx context.Context, id uuid.UUID) (*InterpretationTranslation, error) {
	return c.Query().Where(interpretationtranslation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InterpretationTranslationClient) GetX(ctx context.Context, id uuid.UUID) *InterpretationTranslation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInterpretation queries the interpretation edge of a InterpretationTranslation.
func (c *InterpretationTranslationClient) QueryInterpretation(it *InterpretationTranslation) *InterpretationQuery {
	query := &InterpretationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interpretationtranslation.Table, interpretationtranslation.FieldID, id),
			sqlgraph.To(interpretation.Table, interpretation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, interpretationtranslation.InterpretationTable, interpretationtranslation.InterpretationColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InterpretationTranslationClient) Hooks() []Hook {
	return c.hooks.InterpretationTranslation
}

// ItemClient is a client for the Item schema.
type ItemClient struct {
	config
}

// NewItemClient returns a client for the Item from the given config.
func NewItemClient(c config) *ItemClient {
	return &ItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `item.Hooks(f(g(h())))`.
func (c *ItemClient) Use(hooks ...Hook) {
	c.hooks.Item = append(c.hooks.Item, hooks...)
}

// Create returns a builder for creating a Item entity.
func (c *ItemClient) Create() *ItemCreate {
	mutation := newItemMutation(c.config, OpCreate)
	return &ItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Item entities.
func (c *ItemClient) CreateBulk(builders ...*ItemCreate) *ItemCreateBulk {
	return &ItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Item.
func (c *ItemClient) Update() *ItemUpdate {
	mutation := newItemMutation(c.config, OpUpdate)
	return &ItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ItemClient) UpdateOne(i *Item) *ItemUpdateOne {
	mutation := newItemMutation(c.config, OpUpdateOne, withItem(i))
	return &ItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ItemClient) UpdateOneID(id uuid.UUID) *ItemUpdateOne {
	mutation := newItemMutation(c.config, OpUpdateOne, withItemID(id))
	return &ItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Item.
func (c *ItemClient) Delete() *ItemDelete {
	mutation := newItemMutation(c.config, OpDelete)
	return &ItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ItemClient) DeleteOne(i *Item) *ItemDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ItemClient) DeleteOneID(id uuid.UUID) *ItemDeleteOne {
	builder := c.Delete().Where(item.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ItemDeleteOne{builder}
}

// Query returns a query builder for Item.
func (c *ItemClient) Query() *ItemQuery {
	return &ItemQuery{
		config: c.config,
	}
}

// Get returns a Item entity by its id.
func (c *ItemClient) Get(ctx context.Context, id uuid.UUID) (*Item, error) {
	return c.Query().Where(item.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ItemClient) GetX(ctx context.Context, id uuid.UUID) *Item {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResponses queries the responses edge of a Item.
func (c *ItemClient) QueryResponses(i *Item) *ResponseQuery {
	query := &ResponseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(response.Table, response.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, item.ResponsesTable, item.ResponsesColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTranslations queries the translations edge of a Item.
func (c *ItemClient) QueryTranslations(i *Item) *ItemTranslationQuery {
	query := &ItemTranslationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(itemtranslation.Table, itemtranslation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, item.TranslationsTable, item.TranslationsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScale queries the scale edge of a Item.
func (c *ItemClient) QueryScale(i *Item) *ScaleQuery {
	query := &ScaleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(scale.Table, scale.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, item.ScaleTable, item.ScalePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a Item.
func (c *ItemClient) QueryQuestion(i *Item) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, item.QuestionTable, item.QuestionPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScaleItem queries the scale_item edge of a Item.
func (c *ItemClient) QueryScaleItem(i *Item) *ScaleItemQuery {
	query := &ScaleItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(scaleitem.Table, scaleitem.ItemColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, item.ScaleItemTable, item.ScaleItemColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ItemClient) Hooks() []Hook {
	return c.hooks.Item
}

// ItemTranslationClient is a client for the ItemTranslation schema.
type ItemTranslationClient struct {
	config
}

// NewItemTranslationClient returns a client for the ItemTranslation from the given config.
func NewItemTranslationClient(c config) *ItemTranslationClient {
	return &ItemTranslationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `itemtranslation.Hooks(f(g(h())))`.
func (c *ItemTranslationClient) Use(hooks ...Hook) {
	c.hooks.ItemTranslation = append(c.hooks.ItemTranslation, hooks...)
}

// Create returns a builder for creating a ItemTranslation entity.
func (c *ItemTranslationClient) Create() *ItemTranslationCreate {
	mutation := newItemTranslationMutation(c.config, OpCreate)
	return &ItemTranslationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ItemTranslation entities.
func (c *ItemTranslationClient) CreateBulk(builders ...*ItemTranslationCreate) *ItemTranslationCreateBulk {
	return &ItemTranslationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ItemTranslation.
func (c *ItemTranslationClient) Update() *ItemTranslationUpdate {
	mutation := newItemTranslationMutation(c.config, OpUpdate)
	return &ItemTranslationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ItemTranslationClient) UpdateOne(it *ItemTranslation) *ItemTranslationUpdateOne {
	mutation := newItemTranslationMutation(c.config, OpUpdateOne, withItemTranslation(it))
	return &ItemTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ItemTranslationClient) UpdateOneID(id uuid.UUID) *ItemTranslationUpdateOne {
	mutation := newItemTranslationMutation(c.config, OpUpdateOne, withItemTranslationID(id))
	return &ItemTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ItemTranslation.
func (c *ItemTranslationClient) Delete() *ItemTranslationDelete {
	mutation := newItemTranslationMutation(c.config, OpDelete)
	return &ItemTranslationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ItemTranslationClient) DeleteOne(it *ItemTranslation) *ItemTranslationDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ItemTranslationClient) DeleteOneID(id uuid.UUID) *ItemTranslationDeleteOne {
	builder := c.Delete().Where(itemtranslation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ItemTranslationDeleteOne{builder}
}

// Query returns a query builder for ItemTranslation.
func (c *ItemTranslationClient) Query() *ItemTranslationQuery {
	return &ItemTranslationQuery{
		config: c.config,
	}
}

// Get returns a ItemTranslation entity by its id.
func (c *ItemTranslationClient) Get(ctx context.Context, id uuid.UUID) (*ItemTranslation, error) {
	return c.Query().Where(itemtranslation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ItemTranslationClient) GetX(ctx context.Context, id uuid.UUID) *ItemTranslation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItem queries the item edge of a ItemTranslation.
func (c *ItemTranslationClient) QueryItem(it *ItemTranslation) *ItemQuery {
	query := &ItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := it.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(itemtranslation.Table, itemtranslation.FieldID, id),
			sqlgraph.To(item.Table, item.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, itemtranslation.ItemTable, itemtranslation.ItemColumn),
		)
		fromV = sqlgraph.Neighbors(it.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ItemTranslationClient) Hooks() []Hook {
	return c.hooks.ItemTranslation
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id uuid.UUID) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id uuid.UUID) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id uuid.UUID) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id uuid.UUID) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItems queries the items edge of a Question.
func (c *QuestionClient) QueryItems(q *Question) *ItemQuery {
	query := &ItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(item.Table, item.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, question.ItemsTable, question.ItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTranslations queries the translations edge of a Question.
func (c *QuestionClient) QueryTranslations(q *Question) *QuestionTranslationQuery {
	query := &QuestionTranslationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questiontranslation.Table, questiontranslation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.TranslationsTable, question.TranslationsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the test edge of a Question.
func (c *QuestionClient) QueryTest(q *Question) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, question.TestTable, question.TestPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// QuestionTranslationClient is a client for the QuestionTranslation schema.
type QuestionTranslationClient struct {
	config
}

// NewQuestionTranslationClient returns a client for the QuestionTranslation from the given config.
func NewQuestionTranslationClient(c config) *QuestionTranslationClient {
	return &QuestionTranslationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questiontranslation.Hooks(f(g(h())))`.
func (c *QuestionTranslationClient) Use(hooks ...Hook) {
	c.hooks.QuestionTranslation = append(c.hooks.QuestionTranslation, hooks...)
}

// Create returns a builder for creating a QuestionTranslation entity.
func (c *QuestionTranslationClient) Create() *QuestionTranslationCreate {
	mutation := newQuestionTranslationMutation(c.config, OpCreate)
	return &QuestionTranslationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionTranslation entities.
func (c *QuestionTranslationClient) CreateBulk(builders ...*QuestionTranslationCreate) *QuestionTranslationCreateBulk {
	return &QuestionTranslationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionTranslation.
func (c *QuestionTranslationClient) Update() *QuestionTranslationUpdate {
	mutation := newQuestionTranslationMutation(c.config, OpUpdate)
	return &QuestionTranslationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionTranslationClient) UpdateOne(qt *QuestionTranslation) *QuestionTranslationUpdateOne {
	mutation := newQuestionTranslationMutation(c.config, OpUpdateOne, withQuestionTranslation(qt))
	return &QuestionTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionTranslationClient) UpdateOneID(id uuid.UUID) *QuestionTranslationUpdateOne {
	mutation := newQuestionTranslationMutation(c.config, OpUpdateOne, withQuestionTranslationID(id))
	return &QuestionTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionTranslation.
func (c *QuestionTranslationClient) Delete() *QuestionTranslationDelete {
	mutation := newQuestionTranslationMutation(c.config, OpDelete)
	return &QuestionTranslationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionTranslationClient) DeleteOne(qt *QuestionTranslation) *QuestionTranslationDeleteOne {
	return c.DeleteOneID(qt.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *QuestionTranslationClient) DeleteOneID(id uuid.UUID) *QuestionTranslationDeleteOne {
	builder := c.Delete().Where(questiontranslation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionTranslationDeleteOne{builder}
}

// Query returns a query builder for QuestionTranslation.
func (c *QuestionTranslationClient) Query() *QuestionTranslationQuery {
	return &QuestionTranslationQuery{
		config: c.config,
	}
}

// Get returns a QuestionTranslation entity by its id.
func (c *QuestionTranslationClient) Get(ctx context.Context, id uuid.UUID) (*QuestionTranslation, error) {
	return c.Query().Where(questiontranslation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionTranslationClient) GetX(ctx context.Context, id uuid.UUID) *QuestionTranslation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestion queries the question edge of a QuestionTranslation.
func (c *QuestionTranslationClient) QueryQuestion(qt *QuestionTranslation) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := qt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questiontranslation.Table, questiontranslation.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questiontranslation.QuestionTable, questiontranslation.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(qt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionTranslationClient) Hooks() []Hook {
	return c.hooks.QuestionTranslation
}

// ResponseClient is a client for the Response schema.
type ResponseClient struct {
	config
}

// NewResponseClient returns a client for the Response from the given config.
func NewResponseClient(c config) *ResponseClient {
	return &ResponseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `response.Hooks(f(g(h())))`.
func (c *ResponseClient) Use(hooks ...Hook) {
	c.hooks.Response = append(c.hooks.Response, hooks...)
}

// Create returns a builder for creating a Response entity.
func (c *ResponseClient) Create() *ResponseCreate {
	mutation := newResponseMutation(c.config, OpCreate)
	return &ResponseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Response entities.
func (c *ResponseClient) CreateBulk(builders ...*ResponseCreate) *ResponseCreateBulk {
	return &ResponseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Response.
func (c *ResponseClient) Update() *ResponseUpdate {
	mutation := newResponseMutation(c.config, OpUpdate)
	return &ResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResponseClient) UpdateOne(r *Response) *ResponseUpdateOne {
	mutation := newResponseMutation(c.config, OpUpdateOne, withResponse(r))
	return &ResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResponseClient) UpdateOneID(id uuid.UUID) *ResponseUpdateOne {
	mutation := newResponseMutation(c.config, OpUpdateOne, withResponseID(id))
	return &ResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Response.
func (c *ResponseClient) Delete() *ResponseDelete {
	mutation := newResponseMutation(c.config, OpDelete)
	return &ResponseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResponseClient) DeleteOne(r *Response) *ResponseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ResponseClient) DeleteOneID(id uuid.UUID) *ResponseDeleteOne {
	builder := c.Delete().Where(response.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResponseDeleteOne{builder}
}

// Query returns a query builder for Response.
func (c *ResponseClient) Query() *ResponseQuery {
	return &ResponseQuery{
		config: c.config,
	}
}

// Get returns a Response entity by its id.
func (c *ResponseClient) Get(ctx context.Context, id uuid.UUID) (*Response, error) {
	return c.Query().Where(response.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResponseClient) GetX(ctx context.Context, id uuid.UUID) *Response {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItem queries the item edge of a Response.
func (c *ResponseClient) QueryItem(r *Response) *ItemQuery {
	query := &ItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(response.Table, response.FieldID, id),
			sqlgraph.To(item.Table, item.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, response.ItemTable, response.ItemColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTake queries the take edge of a Response.
func (c *ResponseClient) QueryTake(r *Response) *TakeQuery {
	query := &TakeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(response.Table, response.FieldID, id),
			sqlgraph.To(take.Table, take.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, response.TakeTable, response.TakeColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResponseClient) Hooks() []Hook {
	return c.hooks.Response
}

// ScaleClient is a client for the Scale schema.
type ScaleClient struct {
	config
}

// NewScaleClient returns a client for the Scale from the given config.
func NewScaleClient(c config) *ScaleClient {
	return &ScaleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scale.Hooks(f(g(h())))`.
func (c *ScaleClient) Use(hooks ...Hook) {
	c.hooks.Scale = append(c.hooks.Scale, hooks...)
}

// Create returns a builder for creating a Scale entity.
func (c *ScaleClient) Create() *ScaleCreate {
	mutation := newScaleMutation(c.config, OpCreate)
	return &ScaleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scale entities.
func (c *ScaleClient) CreateBulk(builders ...*ScaleCreate) *ScaleCreateBulk {
	return &ScaleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scale.
func (c *ScaleClient) Update() *ScaleUpdate {
	mutation := newScaleMutation(c.config, OpUpdate)
	return &ScaleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaleClient) UpdateOne(s *Scale) *ScaleUpdateOne {
	mutation := newScaleMutation(c.config, OpUpdateOne, withScale(s))
	return &ScaleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScaleClient) UpdateOneID(id uuid.UUID) *ScaleUpdateOne {
	mutation := newScaleMutation(c.config, OpUpdateOne, withScaleID(id))
	return &ScaleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scale.
func (c *ScaleClient) Delete() *ScaleDelete {
	mutation := newScaleMutation(c.config, OpDelete)
	return &ScaleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScaleClient) DeleteOne(s *Scale) *ScaleDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ScaleClient) DeleteOneID(id uuid.UUID) *ScaleDeleteOne {
	builder := c.Delete().Where(scale.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScaleDeleteOne{builder}
}

// Query returns a query builder for Scale.
func (c *ScaleClient) Query() *ScaleQuery {
	return &ScaleQuery{
		config: c.config,
	}
}

// Get returns a Scale entity by its id.
func (c *ScaleClient) Get(ctx context.Context, id uuid.UUID) (*Scale, error) {
	return c.Query().Where(scale.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScaleClient) GetX(ctx context.Context, id uuid.UUID) *Scale {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItems queries the items edge of a Scale.
func (c *ScaleClient) QueryItems(s *Scale) *ItemQuery {
	query := &ItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scale.Table, scale.FieldID, id),
			sqlgraph.To(item.Table, item.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scale.ItemsTable, scale.ItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInterpretations queries the interpretations edge of a Scale.
func (c *ScaleClient) QueryInterpretations(s *Scale) *InterpretationQuery {
	query := &InterpretationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scale.Table, scale.FieldID, id),
			sqlgraph.To(interpretation.Table, interpretation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scale.InterpretationsTable, scale.InterpretationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTranslations queries the translations edge of a Scale.
func (c *ScaleClient) QueryTranslations(s *Scale) *ScaleTranslationQuery {
	query := &ScaleTranslationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scale.Table, scale.FieldID, id),
			sqlgraph.To(scaletranslation.Table, scaletranslation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scale.TranslationsTable, scale.TranslationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the test edge of a Scale.
func (c *ScaleClient) QueryTest(s *Scale) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scale.Table, scale.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, scale.TestTable, scale.TestPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScaleItem queries the scale_item edge of a Scale.
func (c *ScaleClient) QueryScaleItem(s *Scale) *ScaleItemQuery {
	query := &ScaleItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scale.Table, scale.FieldID, id),
			sqlgraph.To(scaleitem.Table, scaleitem.ScaleColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, scale.ScaleItemTable, scale.ScaleItemColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScaleClient) Hooks() []Hook {
	return c.hooks.Scale
}

// ScaleItemClient is a client for the ScaleItem schema.
type ScaleItemClient struct {
	config
}

// NewScaleItemClient returns a client for the ScaleItem from the given config.
func NewScaleItemClient(c config) *ScaleItemClient {
	return &ScaleItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scaleitem.Hooks(f(g(h())))`.
func (c *ScaleItemClient) Use(hooks ...Hook) {
	c.hooks.ScaleItem = append(c.hooks.ScaleItem, hooks...)
}

// Create returns a builder for creating a ScaleItem entity.
func (c *ScaleItemClient) Create() *ScaleItemCreate {
	mutation := newScaleItemMutation(c.config, OpCreate)
	return &ScaleItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScaleItem entities.
func (c *ScaleItemClient) CreateBulk(builders ...*ScaleItemCreate) *ScaleItemCreateBulk {
	return &ScaleItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScaleItem.
func (c *ScaleItemClient) Update() *ScaleItemUpdate {
	mutation := newScaleItemMutation(c.config, OpUpdate)
	return &ScaleItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaleItemClient) UpdateOne(si *ScaleItem) *ScaleItemUpdateOne {
	mutation := newScaleItemMutation(c.config, OpUpdateOne)
	mutation.Where(scaleitem.ScaleID(si.ScaleID), scaleitem.ItemID(si.ItemID))
	return &ScaleItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScaleItem.
func (c *ScaleItemClient) Delete() *ScaleItemDelete {
	mutation := newScaleItemMutation(c.config, OpDelete)
	return &ScaleItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for ScaleItem.
func (c *ScaleItemClient) Query() *ScaleItemQuery {
	return &ScaleItemQuery{
		config: c.config,
	}
}

// QueryItem queries the item edge of a ScaleItem.
func (c *ScaleItemClient) QueryItem(si *ScaleItem) *ItemQuery {
	return c.Query().
		Where(scaleitem.ScaleID(si.ScaleID), scaleitem.ItemID(si.ItemID)).
		QueryItem()
}

// QueryScale queries the scale edge of a ScaleItem.
func (c *ScaleItemClient) QueryScale(si *ScaleItem) *ScaleQuery {
	return c.Query().
		Where(scaleitem.ScaleID(si.ScaleID), scaleitem.ItemID(si.ItemID)).
		QueryScale()
}

// Hooks returns the client hooks.
func (c *ScaleItemClient) Hooks() []Hook {
	return c.hooks.ScaleItem
}

// ScaleTranslationClient is a client for the ScaleTranslation schema.
type ScaleTranslationClient struct {
	config
}

// NewScaleTranslationClient returns a client for the ScaleTranslation from the given config.
func NewScaleTranslationClient(c config) *ScaleTranslationClient {
	return &ScaleTranslationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scaletranslation.Hooks(f(g(h())))`.
func (c *ScaleTranslationClient) Use(hooks ...Hook) {
	c.hooks.ScaleTranslation = append(c.hooks.ScaleTranslation, hooks...)
}

// Create returns a builder for creating a ScaleTranslation entity.
func (c *ScaleTranslationClient) Create() *ScaleTranslationCreate {
	mutation := newScaleTranslationMutation(c.config, OpCreate)
	return &ScaleTranslationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScaleTranslation entities.
func (c *ScaleTranslationClient) CreateBulk(builders ...*ScaleTranslationCreate) *ScaleTranslationCreateBulk {
	return &ScaleTranslationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScaleTranslation.
func (c *ScaleTranslationClient) Update() *ScaleTranslationUpdate {
	mutation := newScaleTranslationMutation(c.config, OpUpdate)
	return &ScaleTranslationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaleTranslationClient) UpdateOne(st *ScaleTranslation) *ScaleTranslationUpdateOne {
	mutation := newScaleTranslationMutation(c.config, OpUpdateOne, withScaleTranslation(st))
	return &ScaleTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScaleTranslationClient) UpdateOneID(id uuid.UUID) *ScaleTranslationUpdateOne {
	mutation := newScaleTranslationMutation(c.config, OpUpdateOne, withScaleTranslationID(id))
	return &ScaleTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScaleTranslation.
func (c *ScaleTranslationClient) Delete() *ScaleTranslationDelete {
	mutation := newScaleTranslationMutation(c.config, OpDelete)
	return &ScaleTranslationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScaleTranslationClient) DeleteOne(st *ScaleTranslation) *ScaleTranslationDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ScaleTranslationClient) DeleteOneID(id uuid.UUID) *ScaleTranslationDeleteOne {
	builder := c.Delete().Where(scaletranslation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScaleTranslationDeleteOne{builder}
}

// Query returns a query builder for ScaleTranslation.
func (c *ScaleTranslationClient) Query() *ScaleTranslationQuery {
	return &ScaleTranslationQuery{
		config: c.config,
	}
}

// Get returns a ScaleTranslation entity by its id.
func (c *ScaleTranslationClient) Get(ctx context.Context, id uuid.UUID) (*ScaleTranslation, error) {
	return c.Query().Where(scaletranslation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScaleTranslationClient) GetX(ctx context.Context, id uuid.UUID) *ScaleTranslation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScale queries the scale edge of a ScaleTranslation.
func (c *ScaleTranslationClient) QueryScale(st *ScaleTranslation) *ScaleQuery {
	query := &ScaleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scaletranslation.Table, scaletranslation.FieldID, id),
			sqlgraph.To(scale.Table, scale.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scaletranslation.ScaleTable, scaletranslation.ScaleColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScaleTranslationClient) Hooks() []Hook {
	return c.hooks.ScaleTranslation
}

// TakeClient is a client for the Take schema.
type TakeClient struct {
	config
}

// NewTakeClient returns a client for the Take from the given config.
func NewTakeClient(c config) *TakeClient {
	return &TakeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `take.Hooks(f(g(h())))`.
func (c *TakeClient) Use(hooks ...Hook) {
	c.hooks.Take = append(c.hooks.Take, hooks...)
}

// Create returns a builder for creating a Take entity.
func (c *TakeClient) Create() *TakeCreate {
	mutation := newTakeMutation(c.config, OpCreate)
	return &TakeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Take entities.
func (c *TakeClient) CreateBulk(builders ...*TakeCreate) *TakeCreateBulk {
	return &TakeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Take.
func (c *TakeClient) Update() *TakeUpdate {
	mutation := newTakeMutation(c.config, OpUpdate)
	return &TakeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TakeClient) UpdateOne(t *Take) *TakeUpdateOne {
	mutation := newTakeMutation(c.config, OpUpdateOne, withTake(t))
	return &TakeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TakeClient) UpdateOneID(id uuid.UUID) *TakeUpdateOne {
	mutation := newTakeMutation(c.config, OpUpdateOne, withTakeID(id))
	return &TakeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Take.
func (c *TakeClient) Delete() *TakeDelete {
	mutation := newTakeMutation(c.config, OpDelete)
	return &TakeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TakeClient) DeleteOne(t *Take) *TakeDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TakeClient) DeleteOneID(id uuid.UUID) *TakeDeleteOne {
	builder := c.Delete().Where(take.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TakeDeleteOne{builder}
}

// Query returns a query builder for Take.
func (c *TakeClient) Query() *TakeQuery {
	return &TakeQuery{
		config: c.config,
	}
}

// Get returns a Take entity by its id.
func (c *TakeClient) Get(ctx context.Context, id uuid.UUID) (*Take, error) {
	return c.Query().Where(take.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TakeClient) GetX(ctx context.Context, id uuid.UUID) *Take {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResponses queries the responses edge of a Take.
func (c *TakeClient) QueryResponses(t *Take) *ResponseQuery {
	query := &ResponseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(take.Table, take.FieldID, id),
			sqlgraph.To(response.Table, response.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, take.ResponsesTable, take.ResponsesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the test edge of a Take.
func (c *TakeClient) QueryTest(t *Take) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(take.Table, take.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, take.TestTable, take.TestColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Take.
func (c *TakeClient) QueryUser(t *Take) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(take.Table, take.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, take.UserTable, take.UserColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TakeClient) Hooks() []Hook {
	return c.hooks.Take
}

// TestClient is a client for the Test schema.
type TestClient struct {
	config
}

// NewTestClient returns a client for the Test from the given config.
func NewTestClient(c config) *TestClient {
	return &TestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `test.Hooks(f(g(h())))`.
func (c *TestClient) Use(hooks ...Hook) {
	c.hooks.Test = append(c.hooks.Test, hooks...)
}

// Create returns a builder for creating a Test entity.
func (c *TestClient) Create() *TestCreate {
	mutation := newTestMutation(c.config, OpCreate)
	return &TestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Test entities.
func (c *TestClient) CreateBulk(builders ...*TestCreate) *TestCreateBulk {
	return &TestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Test.
func (c *TestClient) Update() *TestUpdate {
	mutation := newTestMutation(c.config, OpUpdate)
	return &TestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestClient) UpdateOne(t *Test) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTest(t))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestClient) UpdateOneID(id uuid.UUID) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTestID(id))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Test.
func (c *TestClient) Delete() *TestDelete {
	mutation := newTestMutation(c.config, OpDelete)
	return &TestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestClient) DeleteOne(t *Test) *TestDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TestClient) DeleteOneID(id uuid.UUID) *TestDeleteOne {
	builder := c.Delete().Where(test.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestDeleteOne{builder}
}

// Query returns a query builder for Test.
func (c *TestClient) Query() *TestQuery {
	return &TestQuery{
		config: c.config,
	}
}

// Get returns a Test entity by its id.
func (c *TestClient) Get(ctx context.Context, id uuid.UUID) (*Test, error) {
	return c.Query().Where(test.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestClient) GetX(ctx context.Context, id uuid.UUID) *Test {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTakes queries the takes edge of a Test.
func (c *TestClient) QueryTakes(t *Test) *TakeQuery {
	query := &TakeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(take.Table, take.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.TakesTable, test.TakesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a Test.
func (c *TestClient) QueryQuestions(t *Test) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, test.QuestionsTable, test.QuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTranslations queries the translations edge of a Test.
func (c *TestClient) QueryTranslations(t *Test) *TestTranslationQuery {
	query := &TestTranslationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testtranslation.Table, testtranslation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.TranslationsTable, test.TranslationsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScales queries the scales edge of a Test.
func (c *TestClient) QueryScales(t *Test) *ScaleQuery {
	query := &ScaleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(scale.Table, scale.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, test.ScalesTable, test.ScalesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDisplay queries the display edge of a Test.
func (c *TestClient) QueryDisplay(t *Test) *TestDisplayQuery {
	query := &TestDisplayQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testdisplay.Table, testdisplay.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, test.DisplayTable, test.DisplayColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestClient) Hooks() []Hook {
	return c.hooks.Test
}

// TestDisplayClient is a client for the TestDisplay schema.
type TestDisplayClient struct {
	config
}

// NewTestDisplayClient returns a client for the TestDisplay from the given config.
func NewTestDisplayClient(c config) *TestDisplayClient {
	return &TestDisplayClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testdisplay.Hooks(f(g(h())))`.
func (c *TestDisplayClient) Use(hooks ...Hook) {
	c.hooks.TestDisplay = append(c.hooks.TestDisplay, hooks...)
}

// Create returns a builder for creating a TestDisplay entity.
func (c *TestDisplayClient) Create() *TestDisplayCreate {
	mutation := newTestDisplayMutation(c.config, OpCreate)
	return &TestDisplayCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestDisplay entities.
func (c *TestDisplayClient) CreateBulk(builders ...*TestDisplayCreate) *TestDisplayCreateBulk {
	return &TestDisplayCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestDisplay.
func (c *TestDisplayClient) Update() *TestDisplayUpdate {
	mutation := newTestDisplayMutation(c.config, OpUpdate)
	return &TestDisplayUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestDisplayClient) UpdateOne(td *TestDisplay) *TestDisplayUpdateOne {
	mutation := newTestDisplayMutation(c.config, OpUpdateOne, withTestDisplay(td))
	return &TestDisplayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestDisplayClient) UpdateOneID(id uuid.UUID) *TestDisplayUpdateOne {
	mutation := newTestDisplayMutation(c.config, OpUpdateOne, withTestDisplayID(id))
	return &TestDisplayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestDisplay.
func (c *TestDisplayClient) Delete() *TestDisplayDelete {
	mutation := newTestDisplayMutation(c.config, OpDelete)
	return &TestDisplayDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestDisplayClient) DeleteOne(td *TestDisplay) *TestDisplayDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TestDisplayClient) DeleteOneID(id uuid.UUID) *TestDisplayDeleteOne {
	builder := c.Delete().Where(testdisplay.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestDisplayDeleteOne{builder}
}

// Query returns a query builder for TestDisplay.
func (c *TestDisplayClient) Query() *TestDisplayQuery {
	return &TestDisplayQuery{
		config: c.config,
	}
}

// Get returns a TestDisplay entity by its id.
func (c *TestDisplayClient) Get(ctx context.Context, id uuid.UUID) (*TestDisplay, error) {
	return c.Query().Where(testdisplay.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestDisplayClient) GetX(ctx context.Context, id uuid.UUID) *TestDisplay {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the test edge of a TestDisplay.
func (c *TestDisplayClient) QueryTest(td *TestDisplay) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testdisplay.Table, testdisplay.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, testdisplay.TestTable, testdisplay.TestColumn),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestDisplayClient) Hooks() []Hook {
	return c.hooks.TestDisplay
}

// TestTranslationClient is a client for the TestTranslation schema.
type TestTranslationClient struct {
	config
}

// NewTestTranslationClient returns a client for the TestTranslation from the given config.
func NewTestTranslationClient(c config) *TestTranslationClient {
	return &TestTranslationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testtranslation.Hooks(f(g(h())))`.
func (c *TestTranslationClient) Use(hooks ...Hook) {
	c.hooks.TestTranslation = append(c.hooks.TestTranslation, hooks...)
}

// Create returns a builder for creating a TestTranslation entity.
func (c *TestTranslationClient) Create() *TestTranslationCreate {
	mutation := newTestTranslationMutation(c.config, OpCreate)
	return &TestTranslationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestTranslation entities.
func (c *TestTranslationClient) CreateBulk(builders ...*TestTranslationCreate) *TestTranslationCreateBulk {
	return &TestTranslationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestTranslation.
func (c *TestTranslationClient) Update() *TestTranslationUpdate {
	mutation := newTestTranslationMutation(c.config, OpUpdate)
	return &TestTranslationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestTranslationClient) UpdateOne(tt *TestTranslation) *TestTranslationUpdateOne {
	mutation := newTestTranslationMutation(c.config, OpUpdateOne, withTestTranslation(tt))
	return &TestTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestTranslationClient) UpdateOneID(id uuid.UUID) *TestTranslationUpdateOne {
	mutation := newTestTranslationMutation(c.config, OpUpdateOne, withTestTranslationID(id))
	return &TestTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestTranslation.
func (c *TestTranslationClient) Delete() *TestTranslationDelete {
	mutation := newTestTranslationMutation(c.config, OpDelete)
	return &TestTranslationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestTranslationClient) DeleteOne(tt *TestTranslation) *TestTranslationDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TestTranslationClient) DeleteOneID(id uuid.UUID) *TestTranslationDeleteOne {
	builder := c.Delete().Where(testtranslation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestTranslationDeleteOne{builder}
}

// Query returns a query builder for TestTranslation.
func (c *TestTranslationClient) Query() *TestTranslationQuery {
	return &TestTranslationQuery{
		config: c.config,
	}
}

// Get returns a TestTranslation entity by its id.
func (c *TestTranslationClient) Get(ctx context.Context, id uuid.UUID) (*TestTranslation, error) {
	return c.Query().Where(testtranslation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestTranslationClient) GetX(ctx context.Context, id uuid.UUID) *TestTranslation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the test edge of a TestTranslation.
func (c *TestTranslationClient) QueryTest(tt *TestTranslation) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testtranslation.Table, testtranslation.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testtranslation.TestTable, testtranslation.TestColumn),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestTranslationClient) Hooks() []Hook {
	return c.hooks.TestTranslation
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(u *User) *UserSessionQuery {
	query := &UserSessionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersession.Table, usersession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTakes queries the takes edge of a User.
func (c *UserClient) QueryTakes(u *User) *TakeQuery {
	query := &TakeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(take.Table, take.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TakesTable, user.TakesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// UserSessionClient is a client for the UserSession schema.
type UserSessionClient struct {
	config
}

// NewUserSessionClient returns a client for the UserSession from the given config.
func NewUserSessionClient(c config) *UserSessionClient {
	return &UserSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersession.Hooks(f(g(h())))`.
func (c *UserSessionClient) Use(hooks ...Hook) {
	c.hooks.UserSession = append(c.hooks.UserSession, hooks...)
}

// Create returns a builder for creating a UserSession entity.
func (c *UserSessionClient) Create() *UserSessionCreate {
	mutation := newUserSessionMutation(c.config, OpCreate)
	return &UserSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSession entities.
func (c *UserSessionClient) CreateBulk(builders ...*UserSessionCreate) *UserSessionCreateBulk {
	return &UserSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSession.
func (c *UserSessionClient) Update() *UserSessionUpdate {
	mutation := newUserSessionMutation(c.config, OpUpdate)
	return &UserSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSessionClient) UpdateOne(us *UserSession) *UserSessionUpdateOne {
	mutation := newUserSessionMutation(c.config, OpUpdateOne, withUserSession(us))
	return &UserSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSessionClient) UpdateOneID(id int) *UserSessionUpdateOne {
	mutation := newUserSessionMutation(c.config, OpUpdateOne, withUserSessionID(id))
	return &UserSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSession.
func (c *UserSessionClient) Delete() *UserSessionDelete {
	mutation := newUserSessionMutation(c.config, OpDelete)
	return &UserSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSessionClient) DeleteOne(us *UserSession) *UserSessionDeleteOne {
	return c.DeleteOneID(us.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *UserSessionClient) DeleteOneID(id int) *UserSessionDeleteOne {
	builder := c.Delete().Where(usersession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSessionDeleteOne{builder}
}

// Query returns a query builder for UserSession.
func (c *UserSessionClient) Query() *UserSessionQuery {
	return &UserSessionQuery{
		config: c.config,
	}
}

// Get returns a UserSession entity by its id.
func (c *UserSessionClient) Get(ctx context.Context, id int) (*UserSession, error) {
	return c.Query().Where(usersession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSessionClient) GetX(ctx context.Context, id int) *UserSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSession.
func (c *UserSessionClient) QueryUser(us *UserSession) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersession.Table, usersession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usersession.UserTable, usersession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSessionClient) Hooks() []Hook {
	return c.hooks.UserSession
}
